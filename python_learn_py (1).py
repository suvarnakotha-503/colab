# -*- coding: utf-8 -*-
"""python learn.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19G9oESKKXD8hpK3hND0RZDlsoUUG2wG4
"""

print("program")
cse=123
ece=124
eee=125
total=cse+ece+eee
print(total)
print("completed")

print("hello")

var=12
Var=13
print(var,Var)

#id is used for point the address of variable
a=10
print(a)
print(id(a))

x=2
y=8.5
z=1j
print(type(x))
print(type(y))
print(type(z))

#list mutable
l=[1,"str",6.5]
print(l)
print(l[1])
l[1]="oak"
print(l[1])
#tuple immutable
t=(1,"str",6.5)
print(t)
print(t[2])
#dictionary(mapping) mutable
dict={"alpha":"a",
"beta":"b",
"gamma":"c"}
print(dict)
print(dict["beta"])
#set (un ordered collection of unique elements) mutable
set={"apple","banana","goa","kakinada","rajamundry","apple"}
print(set)
#frozenset immutable
fset=({"apple","banana","goa","kakinada","apple"})
x=frozenset(fset)
print(x)
#boolean
print(10 >9)
#none (nothing) represent no value
a=None
print(a)
#instance check
a=[1,2,3,4,5]
print(isinstance(a,list))

#we use interning for automatically reuses immutable objects like int, str e.t.c to save memory when same valueused repetedly
#(-5 to 256) store memory paremenently
a=10   #integer
b=10
print(id(a))
print(id(b))

a=278
b=278
print(id(a))
print(id(b))

#float does not have interning
a=10.0
b=10.0
print(id(a))
print(id(b))

#strings interns short and frequntly used strings
a="suvi"
b="suvi"
print(id(a))
print(id(b))

a="suvarna kotha is studing in cse"
b="suvarna kotha is studing in cse"
print(id(a))
print(id(b))
name="suvi" #dynamically
name_1="suvi"
print(id(name))
print(id(name_1))
a="su"
b="vi"
c=a+b
print(id(c))

#arthmatic operators (+,-,*,/,%[modulus],**[exponention],//[floor division])
#assigment operators(=,+=,-=,*=,/=,%=)
#comparison operator(used in conitional statements like if,while (output:true or false)==,!=,>=,<=,<,>)
#logical operator(combines multiple conditions(and,or,not))
a=10
b=20
c=30
print(a>b and b>c)
#short circuiting
#using "and" stops evaluting as soon as it encounters a false condition
#if it is true we execute all conditions
a=5
b=10
print(a>b and b<15)
#short circuting with "or" stops evaluting as soon as it encounters a true condition
a=5
b=10
print(a>b or b<15)
#number handling in logical operators we consider (0,0.0,"null string" as false) either this we take true
#the "and" operator is that when all conditions are "true" it returns the last evaluated value
result=(3 and 6 and 13)
print(result)
res=(2 and 0 and 45)
print(res)
#the "or" operator when any condition is true it returns the first evaluated true value
res=3 or 5 or 7
print(res)
res=(0 or 0.0 or "")
print(res)
#chaining comprion of multiple conditions in a single expression(1<x<10) we put x=7
x=7
print(1<x<10)
x=5
print(10<x<20)
#identity operator(is,is not) we req this for to check if two variables share the same memory location,mutable or immutable objects, debugging
a=10
b=10
print(a is b)
print(a is not b)
#membership opetrators are used to test if a value exist in sequence or not(list,tuple,str etc)[in, not in]
list=["apple", "mango", "grapes"]
print("apple" in list)
print("apple" not in list)
#bit wise (binary) operators (&,|,^,~,<<,>>) left shift means multiply with 10
a=10
b=20
print("band",a&b)
print("bor",a|b)
print("bxor",a^b)
print("bnot of a",~a)
print("blsh by 1 of a:",a<<1)
print("brsh by 1 of a:",a>>1)
#ternary operator(we can use if else in the statements)[if-else]
marks=97
res="A" if marks>85 else "B"
print(res)
#walrus operator introduced in python 3.8 version it is one of the assingment operator(:=) we can assing a value to variable as part of an expression
#with out walrus operation
x=20
if x>7:
  print(x)
#with walrus operation
if(x:=20)>5:
  print(x)

#typecastingis process of converting the value of one data type in another and it supports both implicit and explicit
#we need type casting for data comes in differ forms, such as int, float, str but you may to convert it to a single data type
#implicit type casting(automatically)
a=10
b=23.9
res=a+b
print(res)
print(type(res))
#explicit type casting(manually)
age=9
print(type(age))

flow=89.5
print(type(flow))

age=25
str_age=str(age)
print(str_age)
print(type(str_age))

float_val=42.6
float_val=int(float_val)
print(float_val)
print(type(float_val))

pi=3.14
int(pi)
#only it works with int
x=20
print("binary",bin(x))
print("octal",oct(x))
print(("hexadecimal",hex(x)))

#inputs and output functions
#input:gatting data from user-input()
#output:display info back to user-print()
user_input=input("enter your name")
print(user_input)
print(type("user_input"))

age=input("enter your age")
print(age)
print(type(age))

marks=input("enter your marks")
print(marks)
print(type(marks))
#use typecasting
age=int(input("enter age"))
print(age)
print(type(age))

#print()
print("suvi","lohi","swaroop","kish")
print("jntuk","cse","library")
#use sep(separator) in place of space["",_,1,\n]
print("suvi","lohi","swaroop","kish",sep=",", end="\n\n hi good morning \n\n")
print("jntuk","cse","library",sep=":")

#string concatenation(+)
print("hello " + "world")
"good " + "morning"
#fstring introduce in python 3.6
name="suvarna"
age=21
print(f"hello,hi,my name is {name},my age is {age}")
#string formatting
name="suvi"
print("hi , {}" .format(name))
name="suvi"
_name="lohi"
print("hi , {}{}" .format(name,_name))
pi=3.1459
print(f"value of up to 2 decimal places is {pi:.2f}")

#if-else conditions
num=3
if num>5:
  print("number is greater than 5")
  print(num)
  print("exit if")
else:
  print("number is less than or equal to 5")
  print(num)
  print("exit else")
  #elif conditions
marks=89
if marks>=90:
    print("geade A")
elif marks>=80:
    print("grade B")
elif marks>=70:
    print("grade C")
elif marks>=60:
    print("grade D")
elif marks>=50:
    print("grade E")
else:
    print("fail")

marks=90
if marks>=90:
    print("badge")
#nested if-else conditions
age=30
salary=90000
if age>=25:
    if salary>=75000:
        print("eligible for exam")
    elif salary>=65000:
        print("based on performance, eligible for exam")
    else:
        print("not eligible for exam")
elif age>=20:
    if salary>=50000:
          print("paid coaching available")
    elif salary>=30000:
          print("free coaching available")
    else:
          print("no coaching available")
else:
    print("no eligible for exam")
#multiple conditions with logical operators
age=30
is_citizen=True
if age>=18 and is_citizen:
    print("eligible for voting")
else:
    print("not eligible for voting")

is_raining=False
if not is_raining:
    print("take umbrella")
else:
    print("no need for umbrella")

#for loop(itarate over sequence)
#range()
for i in range(3):
  print(i)
for i in range(1,5):
  print(i)
for i in range(1,6,2):
  print(i)
# help(range)
#create table 19
for i in range(19,50,19):
    print(i)
print(list(range(1,10,5)))
print(tuple(range(1,10,5)))
print(set(range(1,10,5)))
#-ve argument
for i in range(-5):  #noting print
    print(i)
for i in range(-25,-20,3):
    print(i)
#looping through list
students=["suvi","lohi","swaroop","kish"]
for stu in students:
    print(stu)
#looping through string
name="suvi"
for s in name:
    print(s)
#nested loop

for i in range(3):
  for j in range(3):
    print(i,j)

for i in range(3):
  for j in range(3):
    print(j,end=" ")
  print()
#for tables(0 based indexing)
rows=2
cols=2
for i in range(rows):
  for j in range(cols):
      print("rows(i),cols(j)")
#1 based indexing
rows=2
cols=2
for i in range(1,rows+1):
  for j in range(1,cols+1):
      print(i,j)
#else with for loop
student=["suvi","lohi","swaroop","kish"]
for stu in student:
    print(stu)
else:
    print("paid successfully")
print("for loops completed")
#break statement
student=["suvi","lohi","swaroop","kish"]
for stu in student:
    if stu=="swaroop":
        break
    print(stu)
else:
    print("paid sucessfully")

for i in []:#nothing will printed
    print(i)
#while loop
i=0
while i<5:
    print(i)
    i+=1
i=0
while i<10:
    print(i)
    if i==3:
        break
    i+=1
else:
    print("numbers are successfully printed")
#nested while
i=0
while i<1:
    j=0
    while i<2:
        print(f"row:{i},col:{j}")
    j+=1
i+=1

#loop control statements(break, continue and pass)
#break:exit the loop
#continue:skip the rest of the current iteration and proceeds the next one
#pass:does noting but act as a placeholder for future code
for i in range(6):
    if i==5:
        continue
    print(i)

i=0
while i < 10:
     if i==5:   #it turns to infinate loop bcz it cannot concider increment stmt
        continue
     print(i)
     i+=1

i=0
while i<10:
    if i==5:
        i+=1
    continue
    print(i)
#pass
for i in range(5):
    pass

#defining and calling functions
#fuction is a block of code ,reusable that perform every single action
#def functon name (parameters):
#celsius to fahrenheat convertion
def cel(celsius):
    fahrenheat=(celsious*9/5)+32
    return fahrenheat
#greet()
def greet():
    print("good morning")
greet()
#parameter
def welcome(name):
    print(f"welcome to python class,{name}")
welcome("suvi")
#default parameters
def marks(value=75):
    res=(value // 5)*100
    print(res)
marks()

def marks(value=75):
    res=(value // 7)*10  #overrite the globle declared value
    print(res)
marks(90)

#return value in a function:a fun have return value to the caller using return keyword
#once function returns,it exists
def square(x):
    return(x*x)
square_9=square(9) #calling function
print(square_9)

def add(a,b):
    return a+b
res=add(87,90)+add(23,78)
print(res)
#retuning multiple vareables
def start(num):
    min_num=min(num)#pack values
    max_num=max(num)
    return min_num,max_num
res=start([32,67,78,23,10,49])
print(res)
min_val,max_val=start([4,6,8,90])
print(min_val)#unpack values
print(max_val)

def start(num):
    min_num=min(num)#pack values
    max_num=max(num)
    avg=sum(num)/len(num)
    return min_num,max_num,avg
min_val,avg_val,max_val=start([67,45,34,12,89,90])
print(min_val)
print(avg_val)
print(max_val)

num=([2,34,56,67,89])
s1,s2,s3=start(num)
print(s1)
print(s2)
print(s3)

#functions with out return statements:does not have explicitly return stmt,it automatically returns None default
def greet():
    print("good morning")
res=greet()
print(res)
print(type(res))

#summing a list
def sum(num):
    total=sum(num)
    return total
sum=([12,23,34,45,56,67,78,89,90])
print(sum)
print(type(sum))
#calculating area and parameter
def ap(len,wed):
    area=len*wed
    parameter=2*(len+wed)
    return(area,parameter)
res=ap(23,56)
print(res)
print(type(res))
#positional,keyword,default parameters or arguments
# positional parameter passed in "specific order" when calling afunction
def greet(name,age):#we use this argument is fixed and known
    print(f"hi,hello my name is {name},i am {age} years old")
greet("suvi",21)
#keyword arguments:argument passed by explicitly starting the parameter name
#self documenting,reduces,use in many parameters
def greet(name,age,city):
    print(f"hi,hello my name is {name},i am {age} years old,i am live in {city}")
greet(name="suvi",age=21,city="raghudevapuram")
#default arguments:end of the parameter list
def greet(name="suvi",age=21,city="raghudevapuram",gender="female"):
    print(f"hi,hello my name is {name},i am {age} years old,i am live in {city},the {gender}")
greet()
#mixed arguments
def greet(name,age,city,gender,phno):#p->k,p->d
    print(f"hi,hello my name is {name},i am {age} years old,i am live in {city},the {gender},my phone number is{phno}")
greet("suvi",gender= "female",age =21,city ="raghudevapuram",phno =9876543210)
#handling arbitary arguments:it refers to ability in py to passa variable no of arguments to a fun without knowing ahead of time how many arg are passed
#you can handle arbitary positional arg using *args(it behaves like a tuple) and arbitary keyword arg using **kwargs(dictionary)
def add(*args):
    print("positional arguments:",args)
res=(12,34,56,78,90)#we use *a in place of *args
print(res)

def add(**kwargs):
    print("keyword arguments:",kwargs)
    print(type(kwargs))
add(a=10,b=20,c=30,d=40,e=50)
#combine both *args and **kwargs
def add(*args,**kwargs):
    print("positional argument:",args)
    print(type(args))
    print("keyword argument:",kwargs)
    print(type(kwargs))
add("suvi","jntuk",collage="bth",city="hydrabad")

#local vareables and global variables
#local:it is one that is defined inside a fun or a block of code
def fun():
    x=10
    print(x)
fun()

#accessing var outside the function
def fun_1():
    x=20
    print(x)
fun_1()
#global var:it define outside of any function or block
x=30
def num():
    print(x)
num()
print(x)

x=40
def num():
    print(x)
num()
#how python internally manages scopes?
x=50
def num():#local variable have high priority
    x=60
    print(x)
num()
print(x)
#it have 4 namespaces local,enclose,global,built-in
#local:{x:12,y:23,z:34},enclose=same,global=same,built-in={len:fun}
#local:it stores the var defined within a function
def loc():
    x=10
    print(x)
loc()
#enclosing:it stores var in an enclosing function this is applicable in case ofnested function
def outer_fun():
    x=20
    def inner_fun():
        print(x)
    inner_fun()
    print(x)
outer_fun()
#global:it stores thevar def atthetoplevelof a script or a file
x=30
def num():
    print(x)
num()
#built-in:which containsbuilt-in fun and exceptions(eg:print(),len(),exception etc)
x=len
print(x("suvi"))
#ex-1
x=500
y=1000
def num():
    x=100
    print(x)
    print(y)
num()
#ex-2
def num():
    x=10.5
    print(x)
num()

#global keyword:use cas is modification
#accessing global variable
x=10
def fun():
    print(x)
fun()
#using global keyword
x=10
def fun():
    global x
    x+=5
    print(x)
fun()
print(x)
#having local variable inside the function
x=10
def fun():
    x=90
    x+=5
    print(x)
fun()
print(x)
#non local keyword:it is used inside nested fun to refer to variables in encoding function scope
#accessing local vareables
x=50
def of():
    x=90
    def inf():
        print(x)
    inf()
of()
print(x)
#modify the local variable
x=20
def of():
    x=40
    def inf():
        nonlocal x
        x+=5
        print(x)
    inf()
of()
print(x)

#lambda function:they are small anonymous fun that are defined using lambda fun
#they can take any no of arguments but have single expression
#it does not allow return keyword
#reg fun can do the actions of lambda fun but lambda fun can not do reg fun
add=lambda x,y,z : x+y*z
print(add)

add=lambda x,y,z : x+y*z
add(10,20,30)
#equivalent regular fun
def add(x,y,z):
    return x+y-z#powerful
add(45,67,87)
#we cannot write multi lines of code in lambda fun it gets an error

fun=lambda x:(x,x+1,x+2,(x+3)*3)
fun(10)

def fun(x):
    y=x+1 #we cannot do complex no
    z=(x+3)*7
    return x,y,z
fun(10)
#default argumentslike a reg fun and it must be defined after non default fun and it is not passed when calling the lambda def val will be used
greet=lambda name,greeting="hello":f"{greeting,name}"
greet("suvi")

def greet(name,greeting="hello"):
    return f"{greeting,name}"
greet("suvi")
#you can pass a varno of positional arg to a lambda fun by using'*' unpacking syntax
#sum_lam=(lambda *args : sum(args))
#sum_lam (12,23,34,45,56)
#keyword:unpack
det=lambda **kwargs : kwargs["name"]
det(name="suvi",age=21)

#list creation and element access
#my_list:ordered collection of items that can be of any data type
#features:indexing,ordered,mutable,allow fdup values
#indexing
my_list=["suvi","lohi","swaroop","kish"]
for item in my_list:
    print(my_list.index(item),end=" ")
#order
my_list=["suvi","lohi","swaroop","kish"]
print(my_list)
#mutable
my_list=["suvi","lohi","swaroop","kish"]
print(my_list)
print(id(my_list))
my_list.append("cse")#append
print(my_list)
print(id(my_list))
my_list.remove("kish")#remove
print(my_list)
print(id(my_list))
my_list=[10,20,30,40,50]#modify
my_list[0]=15
print(my_list)
#allow dup values
my_list=["suvi","lohi","swaroop","kish","kish"]
print(my_list)
#access elements in my_list by using index
my_list=["suvi","lohi","swaroop","kish"]
print(my_list[0])
print(my_list[1])
print(my_list[2])
print(my_list[3])
#gettig length of sa my_list
my_list=["suvi","lohi","swaroop","kish"]
print(len(my_list))
#my_list inside a my_list:when a my_list is append to another my_list the entaire appended my_list is treated ssingle element
my_list=["suvi","lohi","swaroop","kish"]
my_list.append([10,20,30,40])
print(my_list)
print(my_list[2])
print(my_list[4])
#way to create a my_list:empty my_list'[]',using my_list() constructor,using range() fun,using '*' operator(repeated elements)
l1=[]
l2=[]#1
print(l1)
print(l2)

#non empty my_list
l1=["suvi",1,"cse","3"]
l2=list("suvarna")
print(l1)
print(l2)

#list slicing
l=list(range(10,50,5))
print(l)
l[:3:]
l[:3:8]
#genaralized approch to solve python slicing prob:visualize list,understand step direction,start and end index positions,key observations
l=[10,20,30,40,50]
print(l)
l[-1]
#python list:add, update and remove
#update alist
#direct assingment to update list:assign new val to a list(+ve index,-ve index)
li=[1,2,3,4,5,6,7,8,9]
li[2]="suvi"
print(li)
#updatemultiple element slicing(regular slicing,steeped slicing)
lis=[10,20,30,40,50]
lis[20:50]
print(lis)
#reg slicing
l=[1,2,3,4,5,6,7,8,9]
l[1:4]=[10,20,30,40]
print(l)
#stepped slicing
l=[1,2,3,4,5,6]
l[1:4:2]=[20,30]
print(l)
#adding elements to list:append(),extend(),insert()
#append
l=[1,2,3,4,5,6,7,8,9]
l.append(10)
print(l)

l=[2,3,4,5,6]
li=l.append(12) #we cannot add multiple values
print(type(li))
print(l)

l=[1,2,3,4]
l.append([5,6,7])
print(l)
#extend
l=[12,34,56,78,90]
l.extend([10,20,30]) #we cannot give single number
print(l)
#insert
#li=[1,2,3,4,5,6]
#li.index(3, 8)
#print(li)
#remove:remove(),pop(),del,clear()
#remove can remove first occerance of alist
li=[10,20,30,40,50]
li.remove(30)
li
#pop:it removes the element at specified index
li=[10,20,30,40,50]
li.pop(2)
li
#del:it used to del element from a list by index,slice or del the entire list
#del is a keyword not a method
li=[1,2,3,4,5,6,7,8,9]
del li[4]
li
del li[2:6]
li
del  li[1::2] #it cannot complete all elements in alist
li
#clear:removes all element from the list
l=[10,20,30,40,50,60]
l.clear()
l

#list methods with dir()
#python list built in methods append,extract,insert,remove,pop,clear,index,del,sort,reverse,copy
#count: return no of occerrence of a specified elementin a list
l=[1,2,3,4,5,6,7,8,9,3,5,3,5,3,3,3,3,3,3]
v=l.count(3)
print(v)
#sort:sorts th ist in acending(false) or decending order(true)
l=[1,2,3,4,5,6,7,8,9]
l.sort()
print(l)
l.sort(reverse=True)
print(l)
#reverse:reverse element list
l=[1,2,3,4,5]
v=l.reverse()
print(l)
print(v)
#copy
l1=[1,2,3,4,5,6,7,8,9]
l2=l1.copy()
print(l1)
print(l2)
print(id(l1))
print(id(l2))

#list superpowers:sorted,reversed,min,max,all,any,sum(unity)
#unity fun, iterative utilities
#sorted
l=[10,80,30,60,50]
li=sorted(l)
print("new sorted list:",li)
print("original list:",l)

l=[10,50,40,70]
li=sorted(l,reverse=True)
print("new sorted list:",li)
print("original list:",l)

l=[10,50,40,70]
li=sorted(l,reverse=False)
print("new sorted list:",li)
print("original list:",l)
#reversed(iterable)
l=[10,50,40,70]
li=reversed(l)
print(li)
#all(itarable)
marks=[80,85,87,90,67,78,98]
print(all(num>50 for num in marks))
#any(itarable)
marks=[80,85,87,90,67,78,98]
print(any(num>50 for num in marks))
#min(itarable)
marks=[80,85,87,90,67,78,98]
print(min(marks))
#max(itarable)
marks=[80,85,87,90,67,78,98]
print(max(marks))
#sum(itarable)
marks=[80,85,87,90,67,78,98]
print(sum(marks))

#custom sorting with in key parameters
#use key parameter
#inplace sorting(list.sort())
l=[10,20,90,40,80,60]
l.sort()
print(l)
#out placesorting(sorted())
l=[10,20,90,40,80,60]
li=sorted(l)
print(l)
print(li)
#sorting with key parameter:allows coustomization of sorting behavior by specifying that transforms element before sorting
l=["suvarna","lohi","swaroop","kishore"]
l.sort(key=len)
print(l)
#sorting list of tuples by their second element
l=[(8,9),(3,7),(5,6)]
l.sort(key=lambda x:x[1])
print(l)
#sorting str without considering case differences
l=["BANANA","APPLE","ORANGE","mANGO"]
l.sort(key=str.lower)
print(l)
#sorting list of dictionaries by value
l=[{"name": "apple", "price": 1},
   {"name": "banana", "price": 2},
   {"name": "mango", "price": 3}]
l.sort(key=lambda x:x["price"])
sli=[item["name"] for item in l]
print(sli)

#enumerate():allows you to loop over a list and keep trace of the index alongside the element
l=[10,20,30,40,50]
for idx, x in enumerate(l):
    print(idx, x)

l=[10,20,30,40,50]
list(enumerate(l))
#use case:starting index from a diff no
li=[10,20,30,40,50]
list(enumerate(li,start=50))
#zip():allows youn to combine multiple list into pairs of element
l1=[10,20,30,40,50]
l2=[1,2,3,4,5]
l3=[100,200,300,400,500]
list(zip(l1,l2,l3))

l1=[10,20,30,40,50,60,70]
l2=[1,2,3,4,5,6]
l3=[100,200,300,400,500,600,700,800,900]
list(zip(l1,l2,l3))
#zip() when one list is empty
names=[]
age=[21,22,23] #no output
for x,y in zip(names,age):
    print(x,y)
#iterating with enumerate() and zip()
names=["suvi","lohi","swaroop","kish"]
age=[21,22,22,23]
list(enumerate(zip(names,age)))
#iterating with enumerate() and zip() in a loop
names=["suvi","lohi","swaroop","kish"]
age=[21,22,22,23]
for name,age in enumerate(zip(names,age)):
    print(name,age)

names=["suvi","lohi","swaroop","kish"]
age=[21,22,22,23]
for idx, (name,age) in enumerate(zip(names,age)):
    print(idx,name,age)

#shallow vs deep copy
#understanding memory reference with list assignment
l=[1,2,3,4,5,6]
l1=l
print(l)
print(l1)
print(id(l))
print(id(l1))
#shallow copy:generally faster, but you shouid be cautious when dailing with nested lists
l=[1,2,3,4,5,6]
l1=l.copy()
print(l)
print(l1)
print(id(l))
print(id(l1))
#deep copy:slower and consumes more memory but itis useful when working nested lists
import copy
l=[1,2,3,4,5,6]
l1=copy.deepcopy(l)
print(l)
print(l1)
print(id(l))
print(id(l1))

#tuples:ordered,indexed,unchangeble,allow dup val
t=(12,23,34)
print(t)
t=("apple","banana","cherry")
print(t[2])